"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseJsonRpcTransport = void 0;
const events_1 = require("events");
const errors_1 = require("./errors");
const formatters_1 = require("./formatters");
const httpConnection_1 = require("./httpConnection");
const url_1 = require("./url");
const validators_1 = require("./validators");
const wsConnection_1 = require("./wsConnection");
class BaseJsonRpcTransport {
    constructor(connection) {
        this.events = new events_1.EventEmitter();
        this.connection = this.parseConnection(connection);
        this.onConnectionPayload = this.onConnectionPayload.bind(this);
        this.onConnectionClose = this.onConnectionClose.bind(this);
        this.onConnectionError = this.onConnectionError.bind(this);
    }
    connect(connection = this.connection) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.open(this.parseConnection(connection));
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.close();
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    request(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestStrict(formatters_1.formatJsonRpcRequest(args.method, args.params), context);
        });
    }
    notify(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.notifyStrict(formatters_1.formatJsonRpcNotification(args.method, args.params), context);
        });
    }
    resolve(id, result, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.respondStrict(formatters_1.formatJsonRpcResult(id, result), context);
        });
    }
    reject(id, error, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.respondStrict(formatters_1.formatJsonRpcError(id, error), context);
        });
    }
    // ---------- Private ----------------------------------------------- //
    parseConnection(connection) {
        return typeof connection === 'string'
            ? url_1.isHttpUrl(connection)
                ? new httpConnection_1.HttpConnection(connection)
                : new wsConnection_1.WsConnection(connection)
            : connection;
    }
    requestStrict(request, context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.connection.connected) {
                yield this.open();
            }
            return new Promise((resolve, reject) => {
                this.events.on(`${request.id}`, (response) => {
                    if (validators_1.isJsonRpcError(response)) {
                        reject(new errors_1.RpcError(response.error));
                    }
                    else {
                        resolve(response.result);
                    }
                });
                this.connection.send(request, context);
            });
        });
    }
    notifyStrict(notification, context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.connection.connected) {
                yield this.open();
            }
            yield this.connection.send(notification, context);
        });
    }
    respondStrict(response, context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.connection.connected) {
                yield this.open();
            }
            yield this.connection.send(response, context);
        });
    }
    onConnectionPayload(payload) {
        this.events.emit('payload', payload);
        if (validators_1.isJsonRpcRequest(payload)) {
            this.events.emit('request', payload);
        }
        else if (validators_1.isJsonRpcNotification(payload)) {
            this.events.emit('notification', payload);
        }
        else if (validators_1.isJsonRpcResponse(payload)) {
            this.events.emit(`${payload.id}`, payload);
        }
    }
    onConnectionClose() {
        this.events.emit('disconnect');
    }
    onConnectionError() {
        this.events.emit('error');
    }
    open(connection = this.connection) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.connection === connection && this.connection.connected) {
                return;
            }
            if (this.connection.connected) {
                this.close();
            }
            this.connection = connection;
            yield this.connection.open();
            this.connection.on('payload', this.onConnectionPayload);
            this.connection.on('close', this.onConnectionClose);
            this.connection.on('error', this.onConnectionError);
            this.events.emit('connect');
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.connection.close();
            this.connection.removeListener('payload', this.onConnectionPayload);
            this.connection.removeListener('close', this.onConnectionClose);
            this.connection.removeListener('error', this.onConnectionError);
            this.events.emit('disconnect');
        });
    }
}
exports.BaseJsonRpcTransport = BaseJsonRpcTransport;
//# sourceMappingURL=baseJsonRpcTransport.js.map