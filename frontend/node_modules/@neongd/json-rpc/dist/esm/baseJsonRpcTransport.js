var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { EventEmitter } from 'events';
import { RpcError } from './errors';
import { formatJsonRpcError, formatJsonRpcNotification, formatJsonRpcRequest, formatJsonRpcResult, } from './formatters';
import { HttpConnection } from './httpConnection';
import { isHttpUrl } from './url';
import { isJsonRpcError, isJsonRpcNotification, isJsonRpcRequest, isJsonRpcResponse, } from './validators';
import { WsConnection } from './wsConnection';
export class BaseJsonRpcTransport {
    constructor(connection) {
        this.events = new EventEmitter();
        this.connection = this.parseConnection(connection);
        this.onConnectionPayload = this.onConnectionPayload.bind(this);
        this.onConnectionClose = this.onConnectionClose.bind(this);
        this.onConnectionError = this.onConnectionError.bind(this);
    }
    connect(connection = this.connection) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.open(this.parseConnection(connection));
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.close();
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    request(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestStrict(formatJsonRpcRequest(args.method, args.params), context);
        });
    }
    notify(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.notifyStrict(formatJsonRpcNotification(args.method, args.params), context);
        });
    }
    resolve(id, result, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.respondStrict(formatJsonRpcResult(id, result), context);
        });
    }
    reject(id, error, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.respondStrict(formatJsonRpcError(id, error), context);
        });
    }
    // ---------- Private ----------------------------------------------- //
    parseConnection(connection) {
        return typeof connection === 'string'
            ? isHttpUrl(connection)
                ? new HttpConnection(connection)
                : new WsConnection(connection)
            : connection;
    }
    requestStrict(request, context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.connection.connected) {
                yield this.open();
            }
            return new Promise((resolve, reject) => {
                this.events.on(`${request.id}`, (response) => {
                    if (isJsonRpcError(response)) {
                        reject(new RpcError(response.error));
                    }
                    else {
                        resolve(response.result);
                    }
                });
                this.connection.send(request, context);
            });
        });
    }
    notifyStrict(notification, context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.connection.connected) {
                yield this.open();
            }
            yield this.connection.send(notification, context);
        });
    }
    respondStrict(response, context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.connection.connected) {
                yield this.open();
            }
            yield this.connection.send(response, context);
        });
    }
    onConnectionPayload(payload) {
        this.events.emit('payload', payload);
        if (isJsonRpcRequest(payload)) {
            this.events.emit('request', payload);
        }
        else if (isJsonRpcNotification(payload)) {
            this.events.emit('notification', payload);
        }
        else if (isJsonRpcResponse(payload)) {
            this.events.emit(`${payload.id}`, payload);
        }
    }
    onConnectionClose() {
        this.events.emit('disconnect');
    }
    onConnectionError() {
        this.events.emit('error');
    }
    open(connection = this.connection) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.connection === connection && this.connection.connected) {
                return;
            }
            if (this.connection.connected) {
                this.close();
            }
            this.connection = connection;
            yield this.connection.open();
            this.connection.on('payload', this.onConnectionPayload);
            this.connection.on('close', this.onConnectionClose);
            this.connection.on('error', this.onConnectionError);
            this.events.emit('connect');
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.connection.close();
            this.connection.removeListener('payload', this.onConnectionPayload);
            this.connection.removeListener('close', this.onConnectionClose);
            this.connection.removeListener('error', this.onConnectionError);
            this.events.emit('disconnect');
        });
    }
}
//# sourceMappingURL=baseJsonRpcTransport.js.map