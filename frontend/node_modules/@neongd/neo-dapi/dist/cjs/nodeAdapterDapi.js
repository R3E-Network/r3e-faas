"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeAdapterDapi = void 0;
const neon_js_1 = require("@cityofzion/neon-js");
const json_rpc_1 = require("@neongd/json-rpc");
const _1 = require(".");
class NodeAdapterDapi {
    constructor(urlOrTransport) {
        if (typeof urlOrTransport === 'string') {
            this.transport = new json_rpc_1.BaseJsonRpcTransport(urlOrTransport);
        }
        else {
            this.transport = urlOrTransport;
        }
    }
    getProvider() {
        throw new json_rpc_1.RpcError(json_rpc_1.getStandardErrorResponse(json_rpc_1.StandardErrorCodes.MethodNotFound));
    }
    getNetworks() {
        throw new json_rpc_1.RpcError(json_rpc_1.getStandardErrorResponse(json_rpc_1.StandardErrorCodes.MethodNotFound));
    }
    getAccount() {
        throw new json_rpc_1.RpcError(json_rpc_1.getStandardErrorResponse(json_rpc_1.StandardErrorCodes.MethodNotFound));
    }
    getBlockCount() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.transport
                .request({
                method: 'getblockcount',
                params: [],
            })
                .catch(this.convertRemoteRpcError);
            return result;
        });
    }
    getBlock(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.transport
                .request({
                method: 'getblock',
                params: [params.blockIndex, true],
            })
                .catch(this.convertRemoteRpcError);
            return {
                hash: result.hash,
                size: result.size,
                version: result.version,
                previousBlockHash: result.previousblockhash,
                merkleRoot: result.merkleroot,
                time: result.time,
                index: result.index,
                primary: result.primary,
                nextConsensus: result.nextconsensus,
                witnesses: result.witnesses,
                tx: result.tx.map(this.deserializeTransaction.bind(this)),
                confirmations: result.confirmations,
                nextBlockHash: result.nextblockhash,
            };
        });
    }
    getTransaction(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.transport
                .request({
                method: 'getrawtransaction',
                params: [params.txid, true],
            })
                .catch(this.convertRemoteRpcError);
            return this.deserializeTransaction(result);
        });
    }
    getApplicationLog(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.transport
                .request({
                method: 'getapplicationlog',
                params: [params.txid],
            })
                .catch(this.convertRemoteRpcError);
            return {
                txid: result.txid,
                executions: result.executions.map((execution) => ({
                    trigger: execution.trigger,
                    vmState: execution.vmstate,
                    exception: execution.exception,
                    gasConsumed: execution.gasconsumed,
                    stack: execution.stack,
                    notifications: execution.notifications.map((notification) => ({
                        contract: notification.contract,
                        eventName: notification.eventname,
                        state: notification.state,
                    })),
                })),
            };
        });
    }
    getStorage(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.transport
                .request({
                method: 'getstorage',
                params: [params.scriptHash, params.key],
            })
                .catch(this.convertRemoteRpcError);
            return result;
        });
    }
    getNep17Balances(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.transport
                .request({
                method: 'getnep17balances',
                params: [params.address],
            })
                .catch(this.convertRemoteRpcError);
            return result.balance.map((balance) => ({
                assetHash: balance.assethash,
                amount: balance.amount,
            }));
        });
    }
    invokeRead(params) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.transport
                .request({
                method: 'invokefunction',
                params: [
                    params.scriptHash,
                    params.operation,
                    (_a = params.args) !== null && _a !== void 0 ? _a : [],
                    ((_b = params.signers) !== null && _b !== void 0 ? _b : []).map(this.serializeSigner.bind(this)),
                ],
            })
                .catch(this.convertRemoteRpcError);
            return {
                script: result.script,
                state: result.state,
                exception: result.exception,
                gasConsumed: result.gasconsumed,
                stack: result.stack,
            };
        });
    }
    invokeReadMulti(params) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const script = neon_js_1.sc.createScript(...params.invocations.map(invocation => {
                var _a;
                return (Object.assign(Object.assign({}, invocation), { args: (_a = invocation.args) === null || _a === void 0 ? void 0 : _a.map(arg => neon_js_1.sc.ContractParam.fromJson(arg)) }));
            }));
            const base64Script = Buffer.from(script, 'hex').toString('base64');
            const result = yield this.transport
                .request({
                method: 'invokescript',
                params: [base64Script, ((_a = params.signers) !== null && _a !== void 0 ? _a : []).map(this.serializeSigner.bind(this))],
            })
                .catch(this.convertRemoteRpcError);
            return {
                script: result.script,
                state: result.state,
                exception: result.exception,
                gasConsumed: result.gasconsumed,
                stack: result.stack,
            };
        });
    }
    invoke(_params) {
        throw new json_rpc_1.RpcError(json_rpc_1.getStandardErrorResponse(json_rpc_1.StandardErrorCodes.MethodNotFound));
    }
    invokeMulti(_params) {
        throw new json_rpc_1.RpcError(json_rpc_1.getStandardErrorResponse(json_rpc_1.StandardErrorCodes.MethodNotFound));
    }
    signMessage(_params) {
        throw new json_rpc_1.RpcError(json_rpc_1.getStandardErrorResponse(json_rpc_1.StandardErrorCodes.MethodNotFound));
    }
    signMessageWithoutSalt(_params) {
        throw new json_rpc_1.RpcError(json_rpc_1.getStandardErrorResponse(json_rpc_1.StandardErrorCodes.MethodNotFound));
    }
    signTransaction(_params) {
        throw new json_rpc_1.RpcError(json_rpc_1.getStandardErrorResponse(json_rpc_1.StandardErrorCodes.MethodNotFound));
    }
    relayTransaction(_params) {
        throw new json_rpc_1.RpcError(json_rpc_1.getStandardErrorResponse(json_rpc_1.StandardErrorCodes.MethodNotFound));
    }
    deserializeTransaction(transaction) {
        return {
            hash: transaction.hash,
            size: transaction.size,
            version: transaction.version,
            nonce: transaction.nonce,
            sender: transaction.sender,
            systemFee: transaction.sysfee,
            networkFee: transaction.netfee,
            validUntilBlock: transaction.validuntilblock,
            signers: transaction.signers.map(this.deserializeSigner.bind(this)),
            attributes: transaction.attributes,
            script: transaction.script,
            witnesses: transaction.witnesses,
            blockHash: transaction.blockhash,
            confirmations: transaction.confirmations,
            blockTime: transaction.blocktime,
        };
    }
    deserializeSigner(signer) {
        return {
            account: signer.account,
            scopes: signer.scopes,
            allowedContracts: signer.allowedcontracts,
            allowedGroups: signer.allowedgroups,
            rules: signer.rules,
        };
    }
    serializeSigner(signer) {
        return {
            account: signer.account,
            scopes: signer.scopes,
            allowedcontracts: signer.allowedContracts,
            allowedgroups: signer.allowedGroups,
            rules: signer.rules,
        };
    }
    convertRemoteRpcError(error) {
        throw new json_rpc_1.RpcError(Object.assign(Object.assign({}, _1.getDapiErrorResponse(_1.DapiErrorCodes.RemoteRpcError)), { data: json_rpc_1.formatErrorResponse(error) }));
    }
}
exports.NodeAdapterDapi = NodeAdapterDapi;
//# sourceMappingURL=nodeAdapterDapi.js.map